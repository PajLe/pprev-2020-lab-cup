//import section

import java_cup.runtime.*;
import java.io.*;
import java.util.*;

import SymbolTable.*;


parser code {:
   public int errNo = 0;
   public int warnNo = 0;
   
   SymbolTable symbolTable;
   
   public static void main( String[] args )
   {
      try
	  {
		   FileReader file = new FileReader( args[0] );
		   java_cup.runtime.Scanner scanner = new MPLexer( file );
		   MPParser parser = new MPParser( scanner );
		   parser.parse();
		   parser.checkWarnings();
		   if ( parser.errNo == 0 && parser.warnNo == 0 )
		      System.out.println( "Analiza zavrsena. U kodu nema gresaka." );
		   else
		      System.out.println( "Analiza zavrsena. Broj gresaka: " + parser.errNo 
		         + " Broj upozorenja: " + parser.warnNo );
	  }
	  catch( Exception e )
	  {
		   System.out.println(e);
	  }
   }
   
   public void checkWarnings()
   {
      SymbolNode current = symbolTable.getVariables();
      while ( current != null )
      {
      	Variable var = ( Variable ) current;
      	if ( var.last_def == -1 && var.last_use == -1 )
      	{
      		System.out.println( "Upozorenje: Promenljiva " + var.name + 
      			" je deklarisana, ali se nigde ne koristi." );
      		warnNo++;
      	}
      	else if ( var.last_def > var.last_use )
      	{
      		System.out.println( "Upozorenje: Vrednost dodeljena promeljivoj " +
      		    var.name + " u liniji " + var.last_def + " se nigde ne koristi." );
      		warnNo++;
      	}
      	current = current.next;
     }
   }
   
   public void syntax_error(Symbol cur_token)
   {
   	  
   }
   
   public void report_error(String message, Object info)
   {
   	   System.out.print( message );
   }
   
   public int getLine()
   {
   	  return (( MPLexer) getScanner()).getLine();
   }
:};

init with {:
	symbolTable = new SymbolTable();
:}

//Terminal symbols
terminal MAIN, LEFTPAR, RIGHTPAR, LEFTCURLY, RIGHTCURLY, SEMICOLON, INT, REAL, BOOL;
terminal IF, ELIF, ELSE, COLON, ASSIGN, LESS, LESSEQ, EQ, NOTEQ, GREATER, GREATEREQ;
terminal String ID;
terminal Integer INTCONST;
terminal Double REALCONST;
terminal Boolean BOOLCONST;

//Nonterminal symbols
non terminal Program, Block, Variables, Statements, Statement, IfStatement;
non terminal ElsePart, ElifList, Elif, ElseStatement, RelOp, Assignment;
non terminal TypeNode Type, RelExpression;
non terminal Constant Const;
non terminal SymbolNode Term;
non terminal Variable Variable;
non terminal ScopeStart;
non terminal ScopeEnd;




//Grammar
Program ::= MAIN LEFTPAR RIGHTPAR Block;

Block ::= ScopeStart Variables Statements ScopeEnd;
             
ScopeStart ::= LEFTCURLY
{:
	parser.symbolTable.addScope();
:};

ScopeEnd ::= RIGHTCURLY
{:
	parser.symbolTable.exitScope();
:};

Variables ::= Variables Variable:var 
{:
	if (!parser.symbolTable.addVar(var.name, var.type)) {
		System.out.println(parser.getLine() + ": Promenljiva " + var.name 
			+ " je vec deklarisana");
		parser.errNo++; 
	}
:}

| Variable:var
{:
	if (!parser.symbolTable.addVar(var.name, var.type)) {
		System.out.println(parser.getLine() + ": Promenljiva " + var.name 
			+ " je vec deklarisana");
		parser.errNo++; 
	}
:};

Variable ::= Type:t ID:name SEMICOLON
{:
	RESULT = new Variable(name, t, null);
:};

Type ::= INT
{:
	RESULT = parser.symbolTable.getType("integer");
:} 

| REAL
{:
	RESULT = parser.symbolTable.getType("real");
:}

| BOOL
{:
	RESULT = parser.symbolTable.getType("boolean");
:};

Statements ::= Statements SEMICOLON Statement 
		   | Statement
		   ;

Statement ::= Assignment
		  | IfStatement
 	 	  ;

IfStatement ::= IF LEFTPAR RelExpression:reType RIGHTPAR COLON Block ElsePart 
{:
	if (reType.tkind != TypeNode.BOOLEAN) {
		System.out.println(parser.getLine() +
			": izraz u IF mora biti tipa Boolean");
		parser.errNo++; 
	}
:};

ElsePart ::= ElifList
         | ElseStatement 
         | 
         ;

ElifList ::= ElifList Elif
         | Elif 
         | ElifList ElseStatement
         ;

Elif ::= ELIF LEFTPAR RelExpression:reType RIGHTPAR COLON Block
{:
	if (reType.tkind != TypeNode.BOOLEAN) {
		System.out.println(parser.getLine() +
			": izraz u ELIF mora biti tipa Boolean");
		parser.errNo++; 
	}
:};

ElseStatement ::= ELSE COLON Block;

RelExpression ::= Term:t1 RelOp Term:t2 
{:
	int realTkind = parser.symbolTable.getType("real").tkind;
	int intTkind = parser.symbolTable.getType("integer").tkind; 
	if (t1.kind == SymbolNode.VARIABLE) {
		Variable var1 = parser.symbolTable.getVar(t1.name);
		if (var1 == null) {
			System.out.println(parser.getLine() + ": Promenljiva " + t1.name 
				+ " nije deklarisana");
			parser.errNo++; 
		} else if (var1.value == null) {
			System.out.println(parser.getLine() + ": Promenljiva " + var1.name 
				+ " nije inicijalizovana");
			parser.errNo++; 
		} else if (var1.type.tkind != realTkind 
						&& var1.type.tkind != intTkind) {
			System.out.println(parser.getLine() + ": Promenljiva " + var1.name 
				+ " mora biti numerickog tipa da bi se primenio relacioni operator");
			parser.errNo++; 
		}
	}
	if (t2.kind == SymbolNode.VARIABLE) {
		Variable var1 = parser.symbolTable.getVar(t2.name);
		if (var1 == null) {
			System.out.println(parser.getLine() + ": Promenljiva " + t2.name 
				+ " nije deklarisana");
			parser.errNo++; 
		} else if (var1.value == null) {
			System.out.println(parser.getLine() + ": Promenljiva " + var1.name 
				+ " nije inicijalizovana");
			parser.errNo++; 
		} else if (var1.type.tkind != realTkind 
						&& var1.type.tkind != intTkind) {
			System.out.println(parser.getLine() + ": Promenljiva " + var1.name 
				+ " mora biti numerickog tipa da bi se primenio relacioni operator");
			parser.errNo++; 
		}
	}
	RESULT = parser.symbolTable.getType("boolean");
:}

| Term:t1
{:
	if (t1.kind == SymbolNode.VARIABLE) {
		Variable var1 = parser.symbolTable.getVar(t1.name);
		if (var1 == null) {
			System.out.println(parser.getLine() + ": Promenljiva " + t1.name 
				+ " nije deklarisana");
			parser.errNo++; 
		} else if (var1.value == null) {
			System.out.println(parser.getLine() + ": Promenljiva " + var1.name 
				+ " nije inicijalizovana");
			parser.errNo++; 
		}
	}
	RESULT = t1.type;
:};

Term ::= ID:name
{:
	Variable var = parser.symbolTable.getVar(name);
	if (var != null)
		RESULT = var;
	else
		RESULT = new Variable(name, null, null);
:}

| Const:c
{:
	RESULT = c;
:};

Const ::= INTCONST:c
{:
	RESULT = new Constant(parser.symbolTable.getType("integer"), c);
:}

| REALCONST:c
{:
	RESULT = new Constant(parser.symbolTable.getType("real"), c);
:}

| BOOLCONST:c
{:
	RESULT = new Constant(parser.symbolTable.getType("boolean"), c);
:};

RelOp ::= LESS
      | LESSEQ
      | EQ 
      | NOTEQ 
      | GREATER 
      | GREATEREQ 
      ;

Assignment ::= ID:name ASSIGN Term:term
{:
	Variable var = parser.symbolTable.getVar(name);
	if (var == null) {
		System.out.println(parser.getLine() + ": Promenljiva " + name 
			+ " nije deklarisana");
		parser.errNo++; 
	}
	if (term.kind == SymbolNode.VARIABLE) {
		Variable var1 = parser.symbolTable.getVar(term.name);
		if (var1 == null) {
			System.out.println(parser.getLine() + ": Promenljiva " + term.name 
				+ " nije deklarisana");
			parser.errNo++; 
		} else if (var1.value == null) {
			System.out.println(parser.getLine() + ": Promenljiva " + var1.name 
				+ " nije inicijalizovana");
			parser.errNo++; 
		} else if (var != null) {
			TypeNode varType = var.type;
			TypeNode var1Type = var1.type;
			if (varType.tkind == parser.symbolTable.getType("real").tkind
					&& var1Type.tkind == parser.symbolTable.getType("integer").tkind
				|| varType.tkind == var1Type.tkind)
				var.value = var1.value;
			else {
				System.out.println(parser.getLine() + ": Promenljive " + var.name
					+ " i " + var1.name + " moraju biti istog tipa");
				parser.errNo++; 
			}
		}
	} else if (var != null && term.kind == SymbolNode.CONSTANT) {
		TypeNode varType = var.type;
		TypeNode constType = term.type;
		if (varType.tkind == parser.symbolTable.getType("real").tkind
				&& constType.tkind == parser.symbolTable.getType("integer").tkind
			|| varType.tkind == constType.tkind)
			var.value = ((Constant)term).value;
		else {
			System.out.println(parser.getLine() + ": Promenljive " + var.name
				+ " i " + term.name + " moraju biti istog tipa");
			parser.errNo++; 
		}
	}
:};



